<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Map Tiles in D3</title>
        <!-- An exercise in learning D3 for DOM manipulation and transitions.
             Coordinate and tile positioning logic cribbed from Modest Maps. 
             A one day hack... Doubtless still glitches to be ironed out! 
             Queueing img requests seems overkill but smooths things out a lot.
             (C) 2011 Tom Carden, released under the same BSD license as D3 itself: 
             https://github.com/mbostock/d3/blob/master/LICENSE
             Forks welcome! -->
        <script src="http://mbostock.github.com/d3/d3.js"></script>
        <script type="text/javascript">

            var coord = [ 2, 2, 2 ],     // col, row, zoom
                roundCoord = null,       // coord at an integer zoom level
                tileSize = [ 256, 256 ], // px
                redraw = null,           // visible here for console hacking
                loadedTiles = {},        // [src] --> millis when load completed
                center = [ window.innerWidth/2, window.innerHeight/2 ];

            // make a tile provider that knows how to wrap tiles around the world
            function provider(d) {
                var c = d.slice();
                var minCol = 0, 
                    maxCol = Math.pow(2,d[2]);                        
                while (c[0] < minCol) c[0] += maxCol;
                while (c[0] >= maxCol) c[0] -= maxCol;
                var z = c[2], x = c[0], y = c[1];
                return 'http://otile1.mqcdn.com/tiles/1.0.0/osm/'+z+'/'+x+'/'+y+'.jpg';
            }
            
            // ----- Queue stuff (should really be wrapped in an object)
            
            var queue = [],
                openRequests = [];
            
            // called with .each, this == <img>
            function addToQueue(d,i) {
                queue.push(this);
            }

            // called with .each, this == <img>
            function removeFromQueue(d,i) {
                // also clear open request
                removeOpenRequest(this);            
                var index = queue.indexOf(this);
                if (index >= 0) {
                    queue.splice(index,1);
                }
            }
            
            function removeOpenRequest(img) {
                var index = openRequests.indexOf(img);
                if (index >= 0) {
                    openRequests.splice(index,1);
                }            
            }
            
            function processQueue() {
                while (openRequests.length < 8 && queue.length > 0) {
                    var request = queue.shift();
                    if (request.parentNode) {
                        // luckily there's a magic mapping inside d3
                        // that knows how to pass the correct data to provider()
                        d3.select(request) 
                            .attr("src", provider);
                        openRequests.push(request);
                    }
                }
            }
            
            // ----- end Queue stuff

            // ----- Tile Positioning Functions
            
            // remove round/ceil for greater accuracy but visible seams
            function left(d) { 
                var scale = Math.pow(2, coord[2]-d[2]),
                    power = Math.pow(2, d[2] - roundCoord[2]),
                    centerCol = roundCoord[0] * power;
                return Math.round(center[0] + (d[0] - centerCol) * tileSize[0] * scale) + 'px'; 
            }
            function top(d) { 
                var scale = Math.pow(2, coord[2]-d[2]),
                    power = Math.pow(2, d[2] - roundCoord[2]),
                    centerRow = roundCoord[1] * power;
                return Math.round(center[1] + (d[1] - centerRow) * tileSize[1] * scale) + 'px'; 
            }
            function width(d) { 
                var scale = Math.pow(2, coord[2]-d[2]);
                return Math.ceil(scale * tileSize[0])+'px'; 
            }
            function height(d) { 
                var scale = Math.pow(2, coord[2]-d[2]);
                return Math.ceil(scale * tileSize[1])+'px'; 
            }          
            
            // for 3D webkit mode
            function transform(d) {
                var scale = Math.pow(2, coord[2]-d[2]);
                // adjust to nearest whole pixel scale (thx @tmcw)
                if (scale * tileSize[0] % 1) {
                    scale += (1 - scale * tileSize[0] % 1) / tileSize[0];
                }                
                var power = Math.pow(2, d[2] - roundCoord[2]),
                    centerCol = roundCoord[0] * power,                    
                    centerRow = roundCoord[1] * power,
                    x = Math.round(center[0] + (d[0] - centerCol) * tileSize[0] * scale),
                    y = Math.round(center[1] + (d[1] - centerRow) * tileSize[1] * scale);
                return 'matrix3d(' +
                    [scale,'0,0,0,0',scale,'0,0,0,0,1,0',
                    (x + (((tileSize[0] * scale) - tileSize[0]) / 2)).toFixed(4),
                    (y + (((tileSize[1] * scale) - tileSize[1]) / 2)).toFixed(4),
                    '0,1'].join(',') + ')';            
            }
            
            // ----- end Tile Positioning Functions
            
            // ----- Coordinate manipulation
            
            // NB:- coords are just Arrays [ x,y,z ]
            // create a new coord with [ col, row, zoom ] (x,y,z)
            // copy a coord with c.slice()
            
            function zoomedBy(c, dz) {
                var power = Math.pow(2,dz);
                return [ c[0] * power, c[1] * power, c[2] + dz ];
            }
            function offsetBy(c, o) {
                return [ c[0] + o[0], c[1] + o[1], c[2] + o[2] ];
            }

            // ----- end Coordinate manipulation

            window.onload = function() {
            
                var chart = d3.select("body")
                                .append("div")
                                    .attr("class", "map")
                                    .style("width", "100%")
                                    .style("height", "100%");
                                    
                redraw = function() {

                    //var t = Date.now();
                    //var t0 = t;

                    // apply coord limits
                    if (coord[2] > 18) {
                        coord = zoomedBy(coord, 18-coord[2]);
                    } else if (coord[2] < 0) {
                        coord = zoomedBy(coord, -coord[2]);
                    }
                    
                    // find coordinate extents of map
                    var tl = offsetBy(coord, [ -center[0] / tileSize[0], -center[1] / tileSize[1], 0 ]),
                        br = offsetBy(coord, [ center[0] / tileSize[0], center[1] / tileSize[1], 0 ]);

                    // round coords to "best" zoom level
                    roundCoord = zoomedBy(coord, Math.round(coord[2])-coord[2]);
                    tl = zoomedBy(tl, Math.round(tl[2])-tl[2]);
                    br = zoomedBy(br, Math.round(br[2])-br[2]);

                    // generate visible tile coords                
                    var cols = d3.range( Math.floor(tl[0]), Math.ceil(br[0]) ),
                        rows = d3.range( Math.floor(tl[1]), Math.ceil(br[1]) ),
                        visibleCoords = [];
                    rows.forEach(function(row) {
                        cols.forEach(function(col) {
                            visibleCoords.push([col,row,roundCoord[2]]);
                        });
                    });
                    
                    // don't show above/below the poles
                    visibleCoords = visibleCoords.filter(function(c) {
                        var minRow = 0, 
                            maxRow = Math.pow(2,c[2]);                    
                        return c[1] >= minRow && c[1] < maxRow;                
                    });
                    
                    // explicitly preserve parent tiles for tiles we haven't already loaded
                    // not strictly necessary but helps with continuity on slow connections
                    var compensationCoords = [];
                        uniqueCompensations = {};
                    visibleCoords.forEach(function(c) {
                        if (c[2] > 0) {
                            var src = provider(c);
                            if (!(src in loadedTiles) || (Date.now() - loadedTiles[src] < 250)) {
                                var parent = zoomedBy(c, -1),
                                    parentSrc = provider(parent);
                                if (parentSrc in loadedTiles && !(parentSrc in uniqueCompensations)) {
                                    uniqueCompensations[parentSrc] = true;
                                    compensationCoords.push(parent);
                                }
                            }
                        }
                    });
                    visibleCoords = compensationCoords.concat(visibleCoords);

                    var map = chart.selectAll('img.tile')
                       .data(visibleCoords, String);

                    // setup new things                        
                    map.enter().append('img')
                        .each(addToQueue) // sets img src 8 at a time
                        .attr("id", String)
                        .attr("class", "tile")
                        .attr("src", "about:blank") // src from provider() is done in a queue
                        .style("opacity", "0.0")
                        .style("z-index", function(d) { return d[2] })
                        .style('-webkit-transform', transform)
//                        .style("left", left)
//                        .style("top", top)
//                        .style("width", width)
//                        .style("height", height)
                        .on('load', function(c) {
                            loadedTiles[this.src] = Date.now();
                            d3.select(this)
                                .transition()
                                    .duration(250)
                                  .style("opacity", "1.0");
                            removeOpenRequest(this);
                            processQueue();
                            d3.timer(redraw,100); // TODO: only remove compensation tiles for this tile instead of a full redraw
                        });

                    // update positions
                    map.style('-webkit-transform', transform);
//                    map.style("left", left)
//                       .style("top", top)
//                       .style("width", width)
//                       .style("height", height);
                    
                    // clean up old things
                    map.exit() 
                        .each(removeFromQueue); 
                        .filter(function(d) {
                            if (!this.complete) {
                                // kill it now
                                this.src = 'about:blank';
                                d3.select(this).remove();
                                return false;
                            }
                            return true;
                        })
                        .style('-webkit-transform', transform)
//                        .style("left", left)
//                        .style("top", top)
//                        .style("width", width)
//                        .style("height", height)
                        .transition()
                            .style("opacity", "0.0")
                            .duration(250)
                            .delay(250)
                            .remove();// */
                    
                    processQueue();

                    return true;
                }
                
                d3.timer(redraw);
                
                chart
                    .on('mousedown.map', function() {
                        var prevMouse = [ d3.event.pageX, d3.event.pageY ];
                        d3.select(window)
                            .on('mousemove.map', function() {
                                var mouse = prevMouse;
                                prevMouse = [ d3.event.pageX, d3.event.pageY ];
                                coord = offsetBy(coord, [
                                    -((prevMouse[0] - mouse[0]) / tileSize[0]),
                                    -((prevMouse[1] - mouse[1]) / tileSize[1]),
                                    0
                                ]);
                                d3.event.preventDefault();
                                d3.event.stopPropagation();
                                d3.timer(redraw);
                            })
                            .on('mouseup.map', function() {
                                prevMouse = null;
                                d3.select(window)
                                    .on('mousemove.map',null)
                                    .on('mouseup.map',null);
                            })
                        d3.event.preventDefault();
                        d3.event.stopPropagation();                        
                    })
                    .on('mousewheel.map', onWheel)
                    .on('DOMMouseScroll.map', onWheel);
                
                function onWheel() {
                    // 18 = max zoom, 0 = min zoom
                    var delta = Math.min(18-coord[2],Math.max(0-coord[2],d3_behavior_zoomDelta()));
                    if (delta != 0) {
                        var mouse = [ d3.event.pageX, d3.event.pageY ];
                        coord = offsetBy(coord, [
                            ((mouse[0]-center[0]) / tileSize[0]),
                            ((mouse[1]-center[1]) / tileSize[1]),
                            0
                        ]);
                        coord = zoomedBy(coord, delta);
                        coord = offsetBy(coord, [ 
                            -((mouse[0]-center[0]) / tileSize[0]),
                            -((mouse[1]-center[1]) / tileSize[1]),
                            0
                        ]);
                        d3.timer(redraw);
                    }
                    d3.event.preventDefault();
                    d3.event.stopPropagation();                        
                }
                    
                d3.select(window).on('resize', function() {
                    center = [ window.innerWidth/2, window.innerHeight/2 ] 
                    d3.timer(redraw);
                });
  
            }
            
            // expose this so our own mousewheel handler can use it
            var d3_behavior_zoomDiv = null;
            
            // detect the pixels that would be scrolled by this wheel event
            function d3_behavior_zoomDelta() {
            
              // mousewheel events are totally broken!
              // https://bugs.webkit.org/show_bug.cgi?id=40441
              // not only that, but Chrome and Safari differ in re. to acceleration!
              if (!d3_behavior_zoomDiv) {
                d3_behavior_zoomDiv = d3.select("body").append("div")
                    .style("visibility", "hidden")
                    .style("top", 0)
                    .style("height", 0)
                    .style("width", 0)
                    .style("overflow-y", "scroll")
                  .append("div")
                    .style("height", "2000px")
                  .node().parentNode;
              }
            
              var e = d3.event, delta;
              try {
                d3_behavior_zoomDiv.scrollTop = 1000;
                d3_behavior_zoomDiv.dispatchEvent(e);
                delta = 1000 - d3_behavior_zoomDiv.scrollTop;
              } catch (error) {
                delta = e.wheelDelta || (-e.detail * 5);
              }
            
              return delta * .005;
            }          
            
		</script>
		<style>
		    html, body {
		        width: 100%;
		        height: 100%;
		        margin: 0;
		        padding: 0;
		        border: 0;
		    }
		    .map {
		        position: relative;
		        overflow: hidden;		    
		    }
		    .tile {
		        position: absolute;
		        margin: 0;
		        padding: 0;
		        border: 0;
		    }
		    p {
		        font: bold 12px sans-serif;
		        position: absolute;
		        display: block;
		        right: 5px;
		        bottom: 5px;
		        color: white;
		        text-shadow: 1px 1px 4px rgba(0,0,0,0.75);
		        z-index: 1000;
		        margin: 0;
		        padding: 5px;
		    }
		    p a {
		        color: white;
		    }
		</style>
    </head>
    <body>
        <div id="#map"></div>
        <p>Tiles &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, CC-BY-SA. Courtesy of <a href="http://www.mapquest.com/" target="_blank">MapQuest</a> <img src="http://developer.mapquest.com/content/osm/mq_logo.png"></p>
    </body>
</html>